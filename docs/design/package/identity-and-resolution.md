# Identity model and repository index

> Part of the [Pathfinder package design](../PATHFINDER-PACKAGE-DESIGN.md).
> See also: [Dependencies](./dependencies.md) · [CLI extensions](./cli-extensions.md)

---

## Identity model

Packages are identified by a **repository** token and a local **id**. The fully qualified identifier (FQI) is `repository/id`.

### Repository

The `repository` field is a short name token that identifies which collection of guides this package belongs to. It is **not** a resolvable URL — it is a stable token, analogous to a Debian repository name ("main", "contrib", "backports").

Examples:

- `"interactive-tutorials"` — the public Grafana guides repository
- `"private-guides"` — a private team's guide collection
- `"sales-enablement"` — a non-Grafana content collection (future)

The mapping from repository token to a concrete location (GitHub repo, API endpoint, artifact registry) is an **external concern**, resolved by a configuration layer that is out of scope for this design. This allows the same package format to work across GitHub, Bitbucket, internal APIs, or any future storage backend.

### Fully qualified identifier

The FQI is always `repository/id`:

- `interactive-tutorials/welcome-to-grafana`
- `private-guides/onboarding-101`

FQIs are used in:

- Dependency references (`depends`, `recommends`, etc.)
- Learning path definitions (`paths.json`)
- Recommender rules
- Future CRD serialization

### Bare ID resolution

When a dependency reference contains no `/`, it is resolved within the same repository. This makes same-repo references concise. In `manifest.json`:

```json
{
  "id": "advanced-alerting",
  "repository": "interactive-tutorials",
  "depends": ["intro-to-alerting"],
  "recommends": ["private-guides/deep-dive-alerting"]
}
```

Here `"intro-to-alerting"` resolves to `interactive-tutorials/intro-to-alerting` (same repo). `"private-guides/deep-dive-alerting"` is a cross-repo reference.

### Default repository

When `repository` is absent, the default is `"interactive-tutorials"`. This provides backwards compatibility for all existing guides, which live in the `interactive-tutorials` repo and do not carry a `repository` field.

---

## Repository index

An FQI identifies a package (`interactive-tutorials/welcome-to-grafana`), but identification is not location. For flat package structures where the `id` matches the directory name, the mapping from FQI to filesystem path is trivial. Nested directories break this: a journey step with id `infrastructure-alerting-find-data-to-alert` lives at `infrastructure-alerting/find-data-to-alert/content.json` — the id carries no structural hint about where to find the content.

Three resolution strategies are possible:

1. **Full tree scan.** Walk the repository, read every `content.json`, build an id → path map at runtime. Expensive and fragile at scale.
2. **Encode paths in identifiers.** Make the id mirror the filesystem hierarchy. This couples identity to physical layout — any directory reorganization changes the id, cascading into every package that references it in `depends`, `recommends`, `steps`, or any other dependency field. This is unacceptable.
3. **Repository-level index.** Each repository publishes a compiled index that maps ids to paths. Consumers read the index; no scanning, no path encoding.

We adopt strategy 3, following the Debian precedent.

### The Debian precedent

Debian package names are flat tokens: `nginx`, `python3`, `libssl-dev`. No path information, no filesystem hint. Resolution works through the **`Packages`** index — a file served by every Debian repository that maps package names to metadata and physical locations:

```
Package: nginx
Version: 1.18.0-6
Filename: pool/main/n/nginx/nginx_1.18.0-6_amd64.deb
Depends: nginx-core (>= 1.18.0-6) | nginx-full (>= 1.18.0-6)
Description: small, powerful, scalable web/proxy server
```

The `Filename` field tells `apt` where within the repository to fetch the `.deb`. The package name `nginx` never changes, even if the repository reorganizes its `pool/` directory structure. The `Packages` file is always a **compiled build artifact**, generated by tools like `dpkg-scanpackages` — never hand-edited.

We adopt the same model: each Pathfinder repository contains a `repository.json` that maps package ids to their paths within the repository.

### The `repository.json` file

Each repository root contains a `repository.json` file. It is a top-level JSON object where keys are package ids and values are objects containing at minimum a `path` field:

```json
{
  "welcome-to-grafana": { "path": "welcome-to-grafana" },
  "infrastructure-alerting": { "path": "infrastructure-alerting" },
  "infrastructure-alerting-find-data-to-alert": { "path": "infrastructure-alerting/find-data-to-alert" },
  "infrastructure-alerting-build-your-query": { "path": "infrastructure-alerting/build-your-query" },
  "infrastructure-alerting-set-conditions": { "path": "infrastructure-alerting/set-conditions" }
}
```

The `path` is relative to the repository root directory. Values are objects (not bare strings) so that the schema can be extended with additional denormalized fields in the future without breaking consumers.

The `repository.json` file deliberately excludes fields that have a single source of truth elsewhere. For example, `type` is not included — it belongs in the package's `manifest.json`. Consumers who need `type` resolve the path from `repository.json` and then read the package's `manifest.json`. This avoids duplication that could diverge, even in a compiled index.

### Compilation, not authoring

`repository.json` is a **compiled build artifact**, never hand-authored. A CLI command (`pathfinder-cli build-repository`) scans the repository tree:

1. Walk the directory tree
2. For each directory containing `content.json`, read the `id` field
3. Record the mapping: `id → relative path from repository root`
4. Write `repository.json`

This file is committed to the repository. A **pre-commit hook** regenerates it on every commit, ensuring it stays in sync with the actual package tree. The CI build chain verifies consistency: compile the index from scratch, diff against the committed version, fail if they diverge. This follows the lockfile pattern — committed for fast reads, but always verifiably reproducible from source.

Because the file is entirely compiled, it can safely be extended with denormalized metadata from `manifest.json` in the future (e.g., `title`, `description`, `targeting.match`) without drift risk. Any such extension is a future decision; the initial specification includes only `path`.

### FQI resolution flow

Given an FQI like `interactive-tutorials/infrastructure-alerting-find-data-to-alert`:

1. **Parse the FQI**: split on first `/` → repository token `interactive-tutorials`, id `infrastructure-alerting-find-data-to-alert`
2. **Resolve the repository token** to a location (currently hardcoded for `interactive-tutorials`; future configuration layer maps tokens to locations — see [deferred concerns](../PATHFINDER-PACKAGE-DESIGN.md#deferred-concerns))
3. **Read `repository.json`** from the repository root
4. **Look up the id** → `{ "path": "infrastructure-alerting/find-data-to-alert" }`
5. **Load the package** at `{repo_root}/infrastructure-alerting/find-data-to-alert/content.json`

For bare id references (same-repo, no `/`), steps 1-2 are skipped — the id is looked up directly in the current repository's `repository.json`.

### Relationship to `index.json`

Today, the recommender consumes a hand-maintained `index.json` for targeting rules (`title`, `summary`, `url`, `match`, `targetPlatform`). In the package model, all of this metadata moves into packages: `targeting` and `description` in `manifest.json`, `title` in `content.json`.

After the migration to the package format, `index.json` becomes unnecessary. The recommender's input can be derived from `repository.json` — either by reading it directly (once denormalized metadata is included) or by a build step that reads `repository.json` for resolution and then extracts targeting data from each package's `manifest.json`.

The migration is incremental: as packages gain `manifest.json` with `targeting`, those entries are compiled into `repository.json`. Guides that haven't migrated yet retain their entries in the legacy `index.json`. When the last guide migrates, `index.json` is deleted.
