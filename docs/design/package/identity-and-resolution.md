# Identity model and repository index

> Part of the [Pathfinder package design](../PATHFINDER-PACKAGE-DESIGN.md).
> See also: [Dependencies](./dependencies.md) · [CLI extensions](./cli-extensions.md)

---

## Identity model

Packages are identified by a **bare ID** — a globally unique string such as `"welcome-to-grafana"` or `"infrastructure-alerting-find-data-to-alert"`. IDs contain no repository prefix, no path information, and no structural encoding. They are flat tokens, like Debian package names (`nginx`, `python3`, `libssl-dev`).

### Bare IDs everywhere

All references throughout the system use bare IDs:

- Dependency references: `"depends": ["welcome-to-grafana"]`
- Learning path definitions (`paths.json`)
- Journey step arrays: `"steps": ["find-data-to-alert", "build-your-query"]`
- Recommender rules
- Future CRD serialization

There is no qualified or scoped reference syntax. The system that resolves a bare ID to a content location is the [package resolver](#package-resolution), not the ID format itself. This means packages can move between repositories without changing their identity or breaking any references.

### Global uniqueness

Because IDs are bare and globally scoped, uniqueness is enforced at two levels:

- **Within a repository:** `pathfinder-cli build-repository` detects duplicate IDs within a single repository and reports them as errors. Two packages in the same repository cannot share an ID.
- **Across repositories:** Cross-repository ID collisions are resolved by **tiered clobber semantics**, not treated as hard errors. Repositories are ordered by authority tier — Grafana core is always the highest tier. When the same ID exists in multiple repositories, the highest-tier repository wins and the lower-tier package is silently shadowed. The `PackageResolver` implements this by searching repositories in tier order and returning the first match (see [package resolution](#package-resolution)).
- **Convention:** IDs are descriptive slug strings (e.g., `"prometheus-grafana-101"`, `"infrastructure-alerting-find-data-to-alert"`). Journey step IDs are prefixed with the journey name by convention to avoid collisions, but this is a naming convention, not a structural requirement.

**Shadowing contract:** Downstream repositories (partner content, team-specific guides) accept that Grafana core can shadow any of their IDs. If a downstream repo creates package X and Grafana core later introduces its own package X, the downstream content becomes unreachable through the resolver. This is the expected trade-off of a flat namespace with tiered authority — the same model used by DNS search domains and Python's `sys.path`. Content authors in downstream repositories should use distinctive, descriptive IDs to minimize collision risk.

### The `repository` field

The `repository` field in `manifest.json` is **provenance metadata** — it records which repository a package originated from. It is not part of the package's identity and is not used for resolution.

Examples:

- `"interactive-tutorials"` — the public Grafana guides repository
- `"private-guides"` — a private team's guide collection
- `"sales-enablement"` — a non-Grafana content collection (future)

When `repository` is absent, the default is `"interactive-tutorials"`. This provides backwards compatibility for all existing guides.

---

## Repository index

A bare ID identifies a package (`welcome-to-grafana`), but identification is not location. For flat package structures where the `id` matches the directory name, the mapping is trivial. Nested directories break this: a journey step with id `infrastructure-alerting-find-data-to-alert` lives at `infrastructure-alerting/find-data-to-alert/content.json` — the id carries no structural hint about where to find the content.

Each repository publishes a compiled `repository.json` that maps bare package IDs to filesystem paths and denormalized metadata, following the Debian `Packages` index precedent. Debian's `Packages` file maps flat package names (`nginx`) to physical locations (`pool/main/n/nginx/...`) and includes denormalized metadata (`Description`, `Depends`, etc.) — all generated by `dpkg-scanpackages`, never hand-edited. We adopt the same model.

### The `repository.json` file

Each repository root contains a `repository.json` file. It is a top-level JSON object where keys are bare package IDs and values are objects containing the package path and denormalized manifest metadata:

```json
{
  "welcome-to-grafana": {
    "path": "welcome-to-grafana/",
    "title": "Welcome to Grafana",
    "type": "guide",
    "description": "Get started with the Grafana UI.",
    "category": "query-visualize",
    "author": { "name": "Interactive Learning", "team": "Grafana Developer Advocacy" },
    "startingLocation": "/",
    "depends": [],
    "recommends": ["first-dashboard"],
    "suggests": [],
    "provides": [],
    "conflicts": [],
    "replaces": [],
    "targeting": { "match": { "urlPrefix": "/" } },
    "testEnvironment": { "tier": "local", "minVersion": "12.2.0" }
  },
  "infrastructure-alerting": {
    "path": "infrastructure-alerting/",
    "title": "Infrastructure alerting",
    "type": "journey",
    "description": "Create your first infrastructure alert rule.",
    "category": "take-action",
    "startingLocation": "/alerting",
    "depends": ["welcome-to-grafana"],
    "recommends": ["prometheus-lj"],
    "suggests": [],
    "provides": ["infrastructure-alerting-configured"],
    "conflicts": [],
    "replaces": []
  },
  "infrastructure-alerting-find-data-to-alert": {
    "path": "infrastructure-alerting/find-data-to-alert/",
    "title": "Find data to alert on",
    "type": "guide"
  },
  "install-alloy": {
    "path": "install-alloy/",
    "title": "Install Grafana Alloy",
    "type": "guide",
    "description": "Download and install Grafana Alloy on your platform.",
    "category": "data-availability",
    "provides": ["alloy-installed"]
  }
}
```

Note that `infrastructure-alerting-find-data-to-alert` is a journey-specific step nested under its journey directory (`infrastructure-alerting/find-data-to-alert/`), while `install-alloy` is a shared step that lives as an independent top-level package (`install-alloy/`). Both are real packages resolved by bare ID through the repository index. Multiple journeys (e.g., `linux-server-integration`, `macos-integration`) can reference `install-alloy` in their `steps` arrays without physical duplication.

The `path` is relative to the repository root directory. Denormalized metadata fields (`title`, `type`, `description`, `category`, `author`, `startingLocation`, all dependency arrays, `targeting`, and `testEnvironment`) are included so that consumers can build dependency graphs, search catalogs, compute learning paths, and derive recommender input from `repository.json` alone — without re-reading every individual `manifest.json`.

**Denormalization decision:** The `repository.json` file includes metadata that has its source of truth in each package's `manifest.json`. This denormalization is safe because `repository.json` is always a compiled build artifact — regenerated from source on every commit and verified in CI. It cannot diverge from the source-of-truth files because it is never hand-edited. Packages without `manifest.json` have only `path` and `title` (read from `content.json`); other fields use schema defaults.

### Compilation, not authoring

`repository.json` is a **compiled build artifact**, never hand-authored. A CLI command (`pathfinder-cli build-repository`) scans the repository tree:

1. Walk the directory tree
2. For each directory containing `content.json`, read `content.json` and optionally `manifest.json`
3. Record the mapping: bare ID → `{ path, ...denormalized metadata }`
4. Apply schema defaults for missing manifest fields
5. Write `repository.json`

This file is committed to the repository. A **pre-commit hook** regenerates it on every commit, ensuring it stays in sync with the actual package tree. The CI build chain verifies consistency: compile the index from scratch, diff against the committed version, fail if they diverge. This follows the lockfile pattern — committed for fast reads, but always verifiably reproducible from source.

### Package resolution

Given a bare ID like `infrastructure-alerting-find-data-to-alert`, the system resolves it to a loadable content location through a tiered resolution strategy. The resolution tiers are tried in order:

1. **Bundled content** — look up the ID in the bundled `repository.json` shipped with the plugin. This covers baseline tutorials that work offline.
2. **Static catalog** — look up the ID in a `packages-catalog.json` fetched from CDN at startup. This covers extended content beyond the bundled baseline.
3. **Registry service** (Phase 7) — query a dynamic registry endpoint. This covers rapid content updates and multi-repo ecosystem scale.

If tier 1 misses, try tier 2. If tier 2 misses, try tier 3 (when available). If all tiers miss, the package is unresolvable.

This tier ordering intentionally implements **clobber semantics**: if the same package ID exists in multiple tiers, the highest-priority tier wins. Bundled content (tier 1) shadows static catalog content, which shadows registry content. This means Grafana core packages always take precedence over downstream repository packages, providing a clean authority hierarchy without requiring structural namespacing.

The plugin runtime reads `repository.json` directly for resolution and dependency metadata. It does **not** consume the CLI-generated dependency graph — that artifact is for the recommender service, visualization, and lint tooling. This keeps client memory bounded as the content corpus grows.

All tiers return the same resolution shape:

```typescript
interface PackageResolution {
  id: string;
  contentUrl: string;
  manifestUrl: string;
  repository: string;
  /** Populated when resolve options request content loading */
  manifest?: ManifestJson;
  /** Populated when resolve options request content loading */
  content?: ContentJson;
}

interface ResolveOptions {
  /** When true, fetch and populate manifest and content on the resolution result */
  loadContent?: boolean;
}

interface PackageResolver {
  resolve(packageId: string, options?: ResolveOptions): Promise<PackageResolution>;
}
```

The `PackageResolver` interface is the abstraction that makes resolution strategy swappable. Resolution always returns the package ID and URLs. When `loadContent` is requested, the resolver also fetches and populates the `manifest` and `content` objects on the result. Callers that only need to know where a package is (e.g., catalog UI) skip the load; callers that need the actual package (e.g., the plugin renderer) pass the flag.

Repositories are internal to the resolver — they are URLs that point to indexes, not first-class objects. The resolver knows its set of repository URLs, fetches their indexes, and builds a merged lookup. The MVP implements bundled resolution; the static catalog and Phase 7 registry service implement the same interface with remote sources. The plugin can run multiple resolution tiers simultaneously during transition, falling back gracefully if a tier is unavailable.

### Relationship to `index.json`

Today, the recommender consumes a hand-maintained `index.json` for targeting rules (`title`, `summary`, `url`, `match`, `targetPlatform`). In the package model, all of this metadata moves into packages: `targeting` and `description` in `manifest.json`, `title` in `content.json`.

After the migration to the package format, `index.json` becomes unnecessary. The recommender's input can be derived from `repository.json`, which includes denormalized metadata from each package's `manifest.json`.

The migration is incremental: as packages gain `manifest.json` with `targeting`, those entries are compiled into `repository.json`. Guides that haven't migrated yet retain their entries in the legacy `index.json`. When the last guide migrates, `index.json` is deleted.
