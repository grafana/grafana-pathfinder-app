# Decision log

> Part of the [Pathfinder package design](../PATHFINDER-PACKAGE-DESIGN.md).

---

Decisions made during the design discussion, with rationale.

| #   | Decision                                                                                | Rationale                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| --- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| D1  | Packages are directories containing `content.json`                                      | Natural extension point for assets, sidecars; aligns with SCORM decomposition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| D2  | Identity: bare globally-unique IDs; `repository` is provenance metadata                 | Bare IDs (no repository prefix) enable packages to move between repositories without breaking references. Resolution from bare ID to content location is handled by the package resolver, not by parsing ID syntax. Global uniqueness enforced at build time and catalog aggregation. (Revised from original FQI model `repository/id` — the implementation plan simplified identity to bare IDs.)                                                                                                                                                                                         |
| D3  | Default repository: `"interactive-tutorials"`                                           | Backwards compat for all existing guides                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| D4  | All references use bare IDs everywhere                                                  | With globally-unique bare IDs (see D2), there is no distinction between same-repo and cross-repo references. All dependency, step, and path references are bare IDs. (Revised from original same-repo bare / cross-repo FQI split.)                                                                                                                                                                                                                                                                                                                                                        |
| D5  | Collision avoidance via naming conventions and tiered clobber                           | Structural namespacing (`repository/id`) was evaluated and rejected — it couples identity to location and adds complexity. Instead, collision risk is managed through: (1) descriptive slug naming conventions that minimize accidental collisions, (2) build-time duplicate detection within repositories, and (3) tiered clobber semantics across repositories where higher-authority tiers shadow lower-authority ones (see D31). (Revised from original "Namespacing from Phase 1" which referenced the FQI model.)                                                                    |
| D6  | Single `category` string                                                                | Aligns with docs team taxonomy; multi-category deferred                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| D7  | `targeting.match` follows recommender's MatchExpr grammar                               | Package suggests, recommender decides; loosely validated to avoid coupling                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| D8  | `paths.json` is a temporary stand-in; will be retired after full migration              | `paths.json` is a lightweight, inadequate predecessor to the dependency graph specification. During transition, curated `paths.json` takes priority and dependency-derived paths fill gaps. After full migration to journey metapackages, `paths.json` will be deleted — a separate milestone will migrate everything that depends on it (badges, icons, platform targeting, estimated time) into the package model. (Revised from original "both coexist" — the coexistence is transitional, not permanent.)                                                                              |
| D9  | Multi-repo resolution: tiered strategy with clobber semantics                           | Resolution is tiered: (1) bundled `repository.json` shipped with plugin, (2) static catalog `packages-catalog.json` fetched from CDN, (3) dynamic registry service (Phase 7). First match wins — higher tiers shadow lower tiers. All tiers return the same `PackageResolution` interface. Graceful degradation: if a tier is unavailable, the next tier handles resolution. (Revised from original "resolution deferred" — the resolution strategy is now fully designed.)                                                                                                                |
| D10 | Grafana-first, extensible for non-Grafana                                               | No gold-plating for SCORM; open extensibility is the goal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| D11 | `build-index` deferred                                                                  | Recommender currently uses separately maintained `index.json`; future CLI command                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| D12 | Vet metadata field names against standards                                              | Cross-reference Dublin Core / IEEE LOM / SCORM before finalizing names                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| D13 | Schema version `"1.1.0"` for package extension                                          | Backward-compatible addition; minor version bump per semver                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| D14 | Separate `content.json` (content) from `manifest.json` (metadata)                       | Follows Debian `control`/`data` separation. Multiple consumers (plugin, recommender, LMS, E2E runner) each need different data; separate files avoid full-parsing a large unified file. Block editor stays focused on content; metadata is managed by different roles with different tools. Eliminates merge conflicts between content and metadata changes.                                                                                                                                                                                                                               |
| D15 | Optional `assets/` directory for non-JSON resources                                     | Aligns with SCORM asset packaging. Images, diagrams, and supplementary files live alongside content. Asset resolution deferred but convention established now.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| D16 | Flat metadata and dependency fields in `manifest.json`                                  | Follows Debian `control` file convention where all fields are peers at the same level. Reduces nesting depth, simplifies authoring and validation. Namespace collision risk is acceptable given the bounded, standards-aligned field inventory (see [namespace collision note](../PATHFINDER-PACKAGE-DESIGN.md#namespace-collision-note)).                                                                                                                                                                                                                                                 |
| D17 | CNF OR syntax for dependency lists (nested arrays)                                      | Maps directly to Debian's comma + pipe semantics (`A \| B, C` → `[["A", "B"], "C"]`). Outer array = AND, inner array = OR. Backwards compatible: existing `["A", "B"]` (all strings) retains AND semantics. No string parsing required; fully validatable with Zod.                                                                                                                                                                                                                                                                                                                        |
| D18 | Default `language` to `"en"`                                                            | All existing content is English. Explicit default avoids mandatory boilerplate while preserving the field for future i18n and SCORM import.                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| D19 | Defer `estimatedDuration` and `difficulty` to Phase 2+                                  | No compelling MVP consumer for either field. No UI component displays them; no recommender logic consumes them. Field names are vetted against IEEE LOM now to avoid future renames. Will be needed if SCORM import or recommendation ranking arrives.                                                                                                                                                                                                                                                                                                                                     |
| D20 | Metadata file named `manifest.json`, not `package.json`                                 | Avoids collision with Node.js `package.json`, which would cause friction with npm, IDEs, GitHub dependency graphs, and toolchain root detection across 100-200+ guide directories. `manifest.json` is semantically accurate (the file is a manifest of identity, metadata, dependencies, and targeting), parallels SCORM's `imsmanifest.xml`, is familiar to web developers (PWA/extension manifests), and survives the Phase 5 `type` expansion (a manifest for a course is still a manifest). No major toolchain claims this filename.                                                   |
| D21 | Journeys use the Debian metapackage model; steps are real packages                      | Package uniformity — one kind of thing, one identity model, one tooling set. Avoids inventing a "sub-unit" concept with scoped identity, fragment notation, or different validation rules. Follows the Debian metapackage precedent for composing coherent experiences from discrete components. Enables step reuse across journeys (the "flavors" advantage visible in the integration journeys that share `install-alloy`, `configure-alloy`, and `install-dashboards-alerts`).                                                                                                          |
| D22 | `type` discriminator pulled forward with `"guide"` and `"journey"`                      | Journeys need the type discriminator now. Originally deferred to Phase 5 for SCORM. The journey `type` establishes the composition pattern that SCORM's `"course"` and `"module"` types will refine, not a separate system.                                                                                                                                                                                                                                                                                                                                                                |
| D23 | `steps` is a new ordered array of bare package IDs, not a Debian dependency construct   | Debian `Depends` has no ordering semantics — `A, B, C` is conjunction, not sequence. Advisory linear ordering requires new machinery layered on top of the Debian model. The `steps` array contains bare package IDs resolved via the repository index (not directory names). It is the single source of truth for step ordering; not dependency chains, not filesystem ordering, not a separate paths file.                                                                                                                                                                               |
| D24 | Step ordering is advisory; journey completion is set-based                              | Users can jump into any step directly. Completion = all steps done, regardless of order. The `steps` array is the suggested reading path, not an enforcement mechanism. This matches the design constraint that journeys should encourage but not require sequential progression.                                                                                                                                                                                                                                                                                                          |
| D25 | Nested package directories are permitted but not required                               | Journey-specific steps may be nested as child directories of their journey (organizational convenience). Shared steps that appear in multiple journeys live as independent top-level packages — following the Debian convention where metapackage dependencies are independently located in the pool, not physically contained. The `steps` array uses bare package IDs resolved via the repository index regardless of physical location. The CLI must handle directory-within-directory package structure but does not require it.                                                       |
| D26 | Package ids do not encode filesystem paths                                              | Coupling identity to physical layout means any directory reorganization changes the id, cascading into every package that references it in `depends`, `recommends`, `steps`, or any other field. Ids are stable flat tokens; the mapping from id to path is an external concern handled by the repository index.                                                                                                                                                                                                                                                                           |
| D27 | Repository-level `repository.json` with denormalized manifest metadata                  | Follows the Debian `Packages` index precedent. Each repository publishes a compiled `repository.json` mapping bare package IDs to relative filesystem paths and denormalized manifest metadata (`title`, `type`, `description`, `category`, `startingLocation`, dependency arrays). Denormalization enables dependency graph building and catalog search from the index alone. (Revised from original path-only format — denormalization was adopted because the file is a compiled artifact that cannot diverge from source.)                                                             |
| D28 | `repository.json` is compiled, never hand-authored; publication strategy varies by repo | Generated by `pathfinder-cli build-repository`. Publication strategy varies by repository change velocity: low-velocity repositories (e.g., bundled guides in the plugin repo) commit it as a lockfile verified in CI; high-velocity repositories (e.g., `interactive-tutorials`) generate it as a CI build artifact and publish directly to CDN, keeping it out of git entirely. The compiled nature of this file is what makes denormalization safe — the source of truth remains each package's `manifest.json`. (Revised to add per-repo publication strategy.)                        |
| D29 | `provides` creates virtual capabilities following Debian semantics                      | Virtual capability names declared in `provides` do NOT need to exist as real packages. This follows the Debian virtual package model: `mail-transport-agent` is provided by `postfix`, `exim4`, etc. but does not exist as a real package. Dependency targets are resolved by checking both real package IDs and virtual capabilities. The graph builder constructs a provides map and uses it during lint and resolution. (Added to resolve a contradiction between the dependency design and the original Phase 1 lint rules.)                                                           |
| D30 | `conflicts` and `replaces` are schema-only in the MVP; enforcement deferred             | Fields are included from Phase 1 for strict adherence to the Debian dependency vocabulary. Content authors can declare relationships and the graph builder represents them as edges. No runtime system enforces these fields in the MVP — defining enforcement without a concrete consumer would risk specifying the wrong behavior. The learning content domain lacks direct analogues to Debian's hard mutual exclusion (`Conflicts`) and automatic removal (`Replaces` + `Breaks`); future enforcement will likely be recommender-level signals rather than hard system constraints.    |
| D31 | Cross-repo ID collisions resolved by tiered clobber semantics, not hard errors          | Repositories are ordered by authority tier — Grafana core is always highest. When the same ID exists in multiple tiers, the highest-tier repository wins and lower-tier packages are silently shadowed. This is the same model as DNS search domains and Python's `sys.path`. Downstream repositories accept the shadowing contract: if Grafana core later introduces a package with the same ID, the downstream content becomes unreachable through the resolver. Content authors in downstream repos should use distinctive IDs to minimize collision risk.                              |
| D32 | Per-repo `repository.json` publication strategy                                         | Low-velocity repositories (bundled guides) commit `repository.json` as a lockfile verified in CI by rebuild-and-diff. High-velocity repositories (`interactive-tutorials`) generate it as a CI build artifact published to CDN alongside guide content, never committed to git. Dependency graph JSON follows the same pattern. This avoids pre-commit hook friction in fast-moving content repos while preserving fast local reads for bundled content.                                                                                                                                   |
| D33 | Journey nesting scoped out for Phase 5 (MVP scoping, not semantic limitation)           | A journey's steps must be guides (`type: "guide"` or absent) in Phase 5. This keeps validation, completion tracking, progress computation, and UI rendering simple. This is an MVP scoping choice, not a fundamental limitation — the Debian model permits metapackages to depend on other metapackages, and nothing in the package identity model prevents a future phase from allowing `steps` to reference other journeys. Hierarchical composition (course → module → lesson) can be introduced as a backward-compatible extension when needed.                                        |
| D34 | Steps do not inherit metadata from journeys                                             | Steps are independently reusable packages — the core value proposition of the metapackage model. If step behavior changed depending on which journey references it (inherited targeting, inherited category), it would introduce context-dependent identity, undermining the "one kind of thing" principle. If a journey needs to customize how a step appears, that is a UI presentation concern, not a metadata inheritance concern.                                                                                                                                                     |
| D35 | Static catalog includes denormalized metadata                                           | The `packages-catalog.json` format includes the same denormalized metadata as `repository.json` (title, type, description, category, startingLocation, dependency arrays) with URLs instead of paths. This enables dependency resolution from the catalog alone without additional per-package manifest fetches. Since the catalog is built by aggregating `repository.json` files that already contain the metadata, denormalization is a natural extension of the build process.                                                                                                         |
| D36 | Open directory semantics — packages may contain arbitrary extension files               | A package directory may contain files and subdirectories beyond the reserved set (`content.json`, `manifest.json`, `assets/`). Extension files are opaque to Pathfinder — not parsed, not validated, not warned about. This follows the Debian model (`.deb` data archives contain arbitrary files) and npm model (`package.json` is the only required file). The recommended convention is one subdirectory per tool; this is not enforced. Extension files do not register in `manifest.json`. Processing semantics are entirely the extension tool's concern, not the package format's. |
