/**
 * Authentication Module for E2E Test Runner
 *
 * This module provides an abstraction layer for authentication in E2E tests,
 * enabling swappable auth strategies for different Grafana environments.
 *
 * @module tests/e2e-runner/auth/grafana-auth
 * @see tests/e2e-runner/design/e2e-test-runner-design.md#authentication-module
 *
 * ## Architecture
 *
 * The auth module uses a strategy pattern to decouple authentication logic
 * from test execution. This enables:
 *
 * 1. **Local development**: Uses `@grafana/plugin-e2e` with `admin.json` state file
 * 2. **CI/CD pipelines**: Same strategy, state file generated by setup scripts
 * 3. **Grafana Cloud**: Future strategy using API tokens or service accounts
 * 4. **Custom environments**: Implement `AuthStrategy` interface for any auth flow
 *
 * ## Default behavior
 *
 * The MVP implementation uses `@grafana/plugin-e2e` authentication which:
 * - Stores session state in `playwright/.auth/admin.json`
 * - Uses Playwright's `storageState` to persist auth across tests
 * - Authenticates once per test run (not per test)
 *
 * ## Extending authentication
 *
 * To add a new auth strategy:
 *
 * 1. Implement the `AuthStrategy` interface
 * 2. Create a factory function that returns your strategy
 * 3. Use the `createAuthContext()` function with your strategy
 *
 * @example Custom auth strategy
 * ```typescript
 * // my-auth-strategy.ts
 * import { AuthStrategy, AuthContext } from './grafana-auth';
 *
 * export const myAuthStrategy: AuthStrategy = {
 *   name: 'my-custom-auth',
 *
 *   async authenticate(page, grafanaUrl) {
 *     // Your custom auth logic here
 *     await page.goto(`${grafanaUrl}/login`);
 *     await page.fill('input[name="user"]', process.env.MY_USER!);
 *     await page.fill('input[name="password"]', process.env.MY_PASSWORD!);
 *     await page.click('button[type="submit"]');
 *     await page.waitForURL(/\/$/); // Wait for redirect to home
 *     return true;
 *   },
 *
 *   async validateSession(page) {
 *     const response = await page.request.get('/api/user');
 *     return response.ok();
 *   },
 *
 *   async refreshSession(page, grafanaUrl) {
 *     return this.authenticate(page, grafanaUrl);
 *   },
 * };
 * ```
 */

import type { Page } from '@playwright/test';

// ============================================
// Types
// ============================================

/**
 * Result of an authentication operation.
 */
export interface AuthResult {
  /** Whether authentication succeeded */
  success: boolean;

  /** Error message if authentication failed */
  error?: string;

  /** Duration of the auth operation in ms */
  durationMs?: number;

  /** User information if available */
  user?: {
    /** Username or login */
    login?: string;
    /** User ID */
    id?: number;
    /** User role */
    role?: string;
  };
}

/**
 * Result of session validation.
 */
export interface SessionValidationResult {
  /** Whether the session is valid */
  valid: boolean;

  /** Error message if session is invalid */
  error?: string;

  /** Time until session expires (if known), in seconds */
  expiresIn?: number;
}

/**
 * Strategy interface for authentication.
 *
 * Implement this interface to create a custom authentication strategy
 * for different Grafana environments (local, cloud, on-prem, etc.).
 *
 * @example Implementing a custom strategy
 * ```typescript
 * const serviceAccountStrategy: AuthStrategy = {
 *   name: 'service-account',
 *   async authenticate(page, grafanaUrl) {
 *     // Service accounts use API tokens, not interactive login
 *     return true; // Auth handled via request headers
 *   },
 *   async validateSession(page) {
 *     const response = await page.request.get('/api/user', {
 *       headers: { Authorization: `Bearer ${process.env.GRAFANA_TOKEN}` }
 *     });
 *     return { valid: response.ok() };
 *   },
 *   async refreshSession() {
 *     return true; // Tokens don't need refresh in the same way
 *   },
 * };
 * ```
 */
export interface AuthStrategy {
  /** Human-readable name for this strategy (for logging) */
  readonly name: string;

  /**
   * Perform initial authentication.
   *
   * This method is called once at the start of test execution to establish
   * an authenticated session. For strategies that use pre-existing auth state
   * (like `@grafana/plugin-e2e`), this may be a no-op.
   *
   * @param page - Playwright Page object
   * @param grafanaUrl - Base URL of the Grafana instance
   * @returns AuthResult indicating success or failure
   */
  authenticate(page: Page, grafanaUrl: string): Promise<AuthResult>;

  /**
   * Validate that the current session is still active.
   *
   * This method is called periodically during test execution to detect
   * session expiry before tests fail with cryptic errors.
   *
   * @param page - Playwright Page object
   * @returns SessionValidationResult indicating session validity
   */
  validateSession(page: Page): Promise<SessionValidationResult>;

  /**
   * Attempt to refresh an expired or expiring session.
   *
   * This method is called when session validation indicates the session
   * is expired or about to expire. Not all strategies support refresh.
   *
   * @param page - Playwright Page object
   * @param grafanaUrl - Base URL of the Grafana instance
   * @returns true if refresh succeeded, false otherwise
   */
  refreshSession(page: Page, grafanaUrl: string): Promise<boolean>;
}

/**
 * Context for authentication operations.
 *
 * Provides a high-level API for auth operations using the configured strategy.
 * Use `createAuthContext()` to create an instance with your desired strategy.
 */
export interface AuthContext {
  /** The authentication strategy being used */
  readonly strategy: AuthStrategy;

  /** The Grafana URL this context is configured for */
  readonly grafanaUrl: string;

  /**
   * Perform authentication using the configured strategy.
   *
   * @param page - Playwright Page object
   * @returns AuthResult indicating success or failure
   */
  authenticate(page: Page): Promise<AuthResult>;

  /**
   * Validate the current session.
   *
   * @param page - Playwright Page object
   * @returns SessionValidationResult indicating session validity
   */
  validateSession(page: Page): Promise<SessionValidationResult>;

  /**
   * Attempt to refresh the session.
   *
   * @param page - Playwright Page object
   * @returns true if refresh succeeded, false otherwise
   */
  refreshSession(page: Page): Promise<boolean>;
}

// ============================================
// Constants
// ============================================

/**
 * Timeout for session validation API calls.
 */
const SESSION_VALIDATION_TIMEOUT_MS = 5000;

/**
 * Timeout for authentication operations.
 */
const AUTH_OPERATION_TIMEOUT_MS = 30000;

// ============================================
// Default Strategy: @grafana/plugin-e2e
// ============================================

/**
 * Default authentication strategy using `@grafana/plugin-e2e`.
 *
 * This strategy relies on Playwright's `storageState` feature which persists
 * session cookies and localStorage between tests. The `@grafana/plugin-e2e`
 * package handles initial authentication and saves state to `admin.json`.
 *
 * ## How it works
 *
 * 1. `@grafana/plugin-e2e` provides fixtures that handle authentication
 * 2. Auth state is saved to `playwright/.auth/admin.json` after first login
 * 3. Subsequent tests reuse the saved state (no login needed)
 * 4. This strategy validates and uses the existing session
 *
 * ## Prerequisites
 *
 * - `@grafana/plugin-e2e` must be installed
 * - Playwright config must use the plugin-e2e fixtures
 * - `playwright/.auth/admin.json` must exist (created by setup)
 *
 * @see https://grafana.com/developers/plugin-tools/e2e-test-a-plugin/introduction
 */
export const pluginE2EAuthStrategy: AuthStrategy = {
  name: 'plugin-e2e',

  async authenticate(page: Page, grafanaUrl: string): Promise<AuthResult> {
    const startTime = Date.now();

    try {
      // The @grafana/plugin-e2e fixtures handle authentication automatically
      // via storageState. We just need to verify the session is valid.
      //
      // Navigate to a protected page to verify auth is working
      const dashboardsUrl = new URL('/dashboards', grafanaUrl).toString();
      await page.goto(dashboardsUrl, {
        waitUntil: 'networkidle',
        timeout: AUTH_OPERATION_TIMEOUT_MS,
      });

      // Check if we were redirected to login (auth failed)
      const currentUrl = page.url();
      if (currentUrl.includes('/login')) {
        return {
          success: false,
          error:
            'Authentication failed - redirected to login page. Ensure @grafana/plugin-e2e is configured correctly.',
          durationMs: Date.now() - startTime,
        };
      }

      // Fetch user info to confirm authentication
      const userResponse = await page.request.get(`${grafanaUrl}/api/user`);
      if (!userResponse.ok()) {
        return {
          success: false,
          error: `Authentication check failed: /api/user returned ${userResponse.status()}`,
          durationMs: Date.now() - startTime,
        };
      }

      // Extract user info from response
      const userData = (await userResponse.json()) as { login?: string; id?: number; role?: string };

      return {
        success: true,
        durationMs: Date.now() - startTime,
        user: {
          login: userData.login,
          id: userData.id,
          role: userData.role,
        },
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        success: false,
        error: `Authentication failed: ${errorMessage}`,
        durationMs: Date.now() - startTime,
      };
    }
  },

  async validateSession(page: Page): Promise<SessionValidationResult> {
    try {
      // Lightweight check using fetch in browser context (preserves session cookies)
      const isValid = await page.evaluate(async () => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        try {
          const response = await fetch('/api/user', {
            signal: controller.signal,
          });
          clearTimeout(timeoutId);
          return response.ok;
        } catch {
          clearTimeout(timeoutId);
          return false;
        }
      });

      if (isValid) {
        return { valid: true };
      }

      return {
        valid: false,
        error: 'Session validation failed - /api/user returned non-OK response',
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      return {
        valid: false,
        error: `Session validation error: ${errorMessage}`,
      };
    }
  },

  async refreshSession(page: Page, grafanaUrl: string): Promise<boolean> {
    // The plugin-e2e strategy doesn't support session refresh directly.
    // If the session is expired, the test should fail and re-authenticate
    // on the next run via the auth setup fixture.
    //
    // For long-running tests, consider using a different strategy that
    // supports token refresh (e.g., service account with token refresh).
    console.warn('[grafana-auth] Session refresh not supported by plugin-e2e strategy');
    return false;
  },
};

// ============================================
// Factory Functions
// ============================================

/**
 * Create an authentication context with the specified strategy.
 *
 * The auth context provides a high-level API for authentication operations
 * bound to a specific Grafana URL and strategy.
 *
 * @param grafanaUrl - Base URL of the Grafana instance
 * @param strategy - Authentication strategy to use (defaults to pluginE2EAuthStrategy)
 * @returns AuthContext bound to the URL and strategy
 *
 * @example Using the default strategy
 * ```typescript
 * const authContext = createAuthContext('http://localhost:3000');
 * const result = await authContext.authenticate(page);
 * if (!result.success) {
 *   throw new Error(result.error);
 * }
 * ```
 *
 * @example Using a custom strategy
 * ```typescript
 * import { myAuthStrategy } from './my-auth-strategy';
 *
 * const authContext = createAuthContext('https://my-grafana.example.com', myAuthStrategy);
 * const result = await authContext.authenticate(page);
 * ```
 */
export function createAuthContext(grafanaUrl: string, strategy: AuthStrategy = pluginE2EAuthStrategy): AuthContext {
  return {
    strategy,
    grafanaUrl,

    async authenticate(page: Page): Promise<AuthResult> {
      return strategy.authenticate(page, grafanaUrl);
    },

    async validateSession(page: Page): Promise<SessionValidationResult> {
      return strategy.validateSession(page);
    },

    async refreshSession(page: Page): Promise<boolean> {
      return strategy.refreshSession(page, grafanaUrl);
    },
  };
}

/**
 * Get the default authentication strategy.
 *
 * Currently returns the `pluginE2EAuthStrategy` which uses `@grafana/plugin-e2e`
 * for authentication via stored session state.
 *
 * @returns The default AuthStrategy
 */
export function getDefaultAuthStrategy(): AuthStrategy {
  return pluginE2EAuthStrategy;
}

// ============================================
// Utility Functions
// ============================================

/**
 * Check if the current session is valid (convenience function).
 *
 * This is a lightweight wrapper around the default strategy's `validateSession`
 * for use in scenarios where you don't need the full AuthContext.
 *
 * @param page - Playwright Page object
 * @returns true if session is valid, false otherwise
 *
 * @example
 * ```typescript
 * if (!await isSessionValid(page)) {
 *   throw new Error('Session expired');
 * }
 * ```
 */
export async function isSessionValid(page: Page): Promise<boolean> {
  const result = await pluginE2EAuthStrategy.validateSession(page);
  return result.valid;
}

/**
 * Perform session validation with detailed result.
 *
 * Use this when you need more information than just a boolean validity check.
 *
 * @param page - Playwright Page object
 * @returns SessionValidationResult with validity and any error details
 */
export async function validateSessionDetailed(page: Page): Promise<SessionValidationResult> {
  return pluginE2EAuthStrategy.validateSession(page);
}
