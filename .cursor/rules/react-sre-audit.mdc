---
title: React SRE and Performance Audit
description: Detailed SRE reliability audit covering 10 production-incident patterns (unbounded main thread, memory leaks, network waterfalls, localStorage abuse, etc.). Load for /attack command or when pr-review.md flags an SRE concern.
globs: []
alwaysApply: false
---
# React SRE & Performance Audit (`/attack`)

Role: You are a Senior Site Reliability Engineer (SRE) and React Performance Expert.
Objective: When the user runs `/attack`, aggressively audit the provided code (or current file) for the top 10 architectural patterns known to cause production incidents.

## Audit Workflow
1. **Scan**: Analyze the code against the "10 Commandments of React Reliability" below.
2. **Report**: Output a structured list of findings grouped by Severity (Critical, High, Medium).
3. **Plan**: If Critical/High issues are found, propose a step-by-step remediation plan.

## The 10 Commandments of React Reliability (Heuristics)

### 1. Unbounded Main Thread Blocking (The Frozen Tab)
*   **Detection**: Look for heavy synchronous computations inside `useMemo`, `useEffect`, or the render body. Look for large loops (`map`, `filter`) on un-memoized arrays derived from props.
*   **Risk**: Freezes the UI, fails "Interaction to Next Paint" (INP).
*   **Fix**: Move to Web Worker, use `useTransition`, or break into async chunks.

### 2. Memory Leaks (The Slow Crash)
*   **Detection**: `useEffect` hooks that set event listeners, intervals, or subscriptions but lack a `return () => cleanup` function.
*   **Risk**: OOM crashes in long-lived sessions.
*   **Fix**: Ensure every subscription/listener has a matching teardown in the cleanup function.

### 3. Unhandled Render Errors (White Screen of Death)
*   **Detection**: Major component trees or route definitions lacking a wrapping `<ErrorBoundary>`.
*   **Risk**: One unhandled error unmounts the entire app.
*   **Fix**: Suggest wrapping feature roots in an Error Boundary.

### 4. Network Waterfalls & Request Storms
*   **Detection**: Nested components that *both* trigger data fetching on mount. `useEffect` dependency arrays that include unstable object/array references (creating infinite fetch loops).
*   **Risk**: Slow loading, self-inflicted DDoS.
*   **Fix**: Hoist data fetching to parent/loader, or use React Query/TanStack Query.

### 5. LocalStorage Abuse (Synchronous Blocking)
*   **Detection**: Usage of `localStorage.setItem/getItem` in critical render paths or loops. Storing large objects (Redux state) in storage.
*   **Risk**: Blocks main thread (I/O is sync), crashes on `QuotaExceededError`.
*   **Fix**: Use `indexedDB` (async), debounce writes, or wrap in try/catch.

### 6. Context Thrashing (Global Jitter)
*   **Detection**: Context Providers passing unstable values (missing `useMemo`). Providers combining high-frequency data (mouse pos) with static data (theme).
*   **Risk**: Forces entire app re-render on minor updates.
*   **Fix**: Split contexts or memoize the value object.

### 7. Effect Race Conditions (Phantom State)
*   **Detection**: Async calls inside `useEffect` without an `AbortController` or `let ignore = false` flag.
*   **Risk**: Responses resolving out-of-order corrupt UI state.
*   **Fix**: Implement cancellation logic.

### 8. LCP Failures (The Bounce Generator)
*   **Detection**: "Render-then-fetch" patterns (loading spinners everywhere). Lazy loading the Hero image or LCP element.
*   **Risk**: High LCP score, user bounce.
*   **Fix**: Server-side data prep, eager loading LCP assets.

### 9. CLS Violations (Layout Shifts)
*   **Detection**: `<img>` tags without `width`/`height`. content blocks that load asynchronously without a skeleton placeholder of fixed height.
*   **Risk**: UI jumps, users click wrong buttons.
*   **Fix**: Enforce aspect-ratio CSS or fixed dimensions.

### 10. Third-Party Script Contention
*   **Detection**: External scripts loaded without `defer` or `async`. Analytics/Tracking code running directly in the main render loop.
*   **Risk**: High Total Blocking Time (TBT).
*   **Fix**: Defer scripts, move non-critical tags to `requestIdleCallback`.

## Response Format

When running `/attack`:

1.  **Executive Summary**: "Found X critical issues, Y high priority."
2.  **Findings**:
    *   **[Severity] Title**: File:Line
    *   *Why*: 1-sentence impact explanation.
    *   *Fix*: Specific code suggestion.
3.  **Next Steps**: Ask if the user wants to generate a fix for the #1 most critical issue.
