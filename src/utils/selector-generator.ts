/**
 * Smart selector generation for DOM elements
 * Creates robust, human-readable selectors while avoiding auto-generated classes
 *
 * This utility is generic and can be used in any context where you need to
 * programmatically generate CSS selectors for DOM elements.
 *
 * Key features:
 * - Walks up DOM hierarchy to find best selectable parent
 * - Prioritizes stable attributes (data-testid, id, aria-label)
 * - Filters out auto-generated classes (Emotion, CSS modules, etc.)
 * - Handles nested elements (clicks on icons/spans find parent button/link)
 * - Context-aware (includes parent selectors when needed)
 *
 * @module selector-generator
 */

import { findButtonByText } from './dom-utils';
import { querySelectorAllEnhanced } from './enhanced-selector';

/**
 * Check if an ID appears to be auto-generated
 */
function isAutoGeneratedId(id: string): boolean {
  // IDs with random hashes or UUIDs
  if (id.length > 20) {
    return true;
  }
  if (/^[a-f0-9]{8,}/.test(id)) {
    return true;
  } // Hex hashes
  if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    return true;
  } // UUID
  if (/^id-\d+/.test(id)) {
    return true;
  } // Auto-incremented IDs
  if (/^react-/.test(id)) {
    return true;
  } // React-generated IDs

  return false;
}

/**
 * Patterns for stable, semantic CSS classes that should be kept
 */
const STABLE_CLASS_PATTERNS = [
  /^[a-z][a-z0-9-]*(__[a-z0-9-]+)?(--[a-z0-9-]+)?$/, // BEM: block__element--modifier
  /^[a-z][a-z0-9-]+$/, // Simple kebab-case (min 2 chars to avoid 'p', 'm', etc.)
];

/**
 * Check if a class matches stable naming patterns
 */
function isStableClass(className: string): boolean {
  return STABLE_CLASS_PATTERNS.some((pattern) => pattern.test(className));
}

/**
 * Check if a class appears to be auto-generated or utility-only
 */
function isAutoGeneratedClass(className: string): boolean {
  // First check if it matches stable patterns (allowlist)
  if (isStableClass(className)) {
    return false;
  }

  // Emotion/styled-components classes
  if (className.startsWith('css-')) {
    return true;
  }

  // More Grafana-specific patterns - be more aggressive
  if (/^css-/.test(className)) {
    return true;
  } // Any css- prefix (emotion/styled-components)
  if (/^[a-z]+-[a-z0-9]{6,}/.test(className)) {
    return true;
  } // emotion-style hashes
  if (className.match(/^_[a-zA-Z0-9]{5,}$/)) {
    return true;
  } // webpack module hashes

  // Classes with long hash patterns (6+ alphanumeric to catch more)
  if (/[a-zA-Z0-9]{6,}/.test(className) && className.includes('-')) {
    return true;
  }

  // Theme classes (dynamic light/dark)
  if (className.startsWith('theme-')) {
    return true;
  }

  // Common utility classes that don't help identify elements
  const utilityClasses = [
    'flex',
    'flex-row',
    'flex-col',
    'block',
    'inline',
    'hidden',
    'absolute',
    'relative',
    'fixed',
    'static',
    'w-full',
    'h-full',
    'p-0',
    'p-1',
    'p-2',
    'p-3',
    'p-4',
    'm-0',
    'm-1',
    'm-2',
    'm-3',
    'm-4',
    'text-left',
    'text-center',
    'text-right',
    'font-bold',
    'font-normal',
    'font-light',
  ];

  if (utilityClasses.includes(className)) {
    return true;
  }

  // Grafana-specific utility patterns
  if (className.match(/^(theme|color|bg|border|rounded|shadow)-/)) {
    return true;
  }

  return false;
}

/**
 * Get unique, meaningful classes from an element
 */
function getMeaningfulClasses(element: HTMLElement): string[] {
  if (!element.className) {
    return [];
  }

  const classes = element.className.split(/\s+/).filter(Boolean);
  return classes.filter((cls) => !isAutoGeneratedClass(cls));
}

/**
 * Normalize text by removing RTL/LTR marks and collapsing whitespace
 */
function normalizeText(text: string): string {
  return text
    .replace(/[\u200e\u200f]/g, '') // Remove RTL/LTR marks
    .replace(/\s+/g, ' ') // Collapse whitespace
    .trim();
}

/**
 * Normalize href by removing query strings and hashes while preserving relative/absolute path
 * Keeps the original path format (relative vs absolute) for exact attribute matching
 */
function normalizeHref(href: string): string {
  try {
    // For URLs with query strings or hashes, strip them
    const hashIndex = href.indexOf('#');
    const queryIndex = href.indexOf('?');

    let endIndex = href.length;
    if (hashIndex > 0) {
      endIndex = hashIndex;
    }
    if (queryIndex > 0 && queryIndex < endIndex) {
      endIndex = queryIndex;
    }

    // Return the path portion, preserving relative vs absolute format
    return href.substring(0, endIndex);
  } catch {
    return href; // Invalid URL, return as-is
  }
}

/**
 * Get test ID from any supported test ID attribute
 * Supports multiple conventions: data-testid, data-cy, data-test-id, data-qa, data-test-subj
 */
function getAnyTestId(element: HTMLElement): string | null {
  const testIdAttrs = ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'];

  for (const attr of testIdAttrs) {
    if (element.hasAttribute(attr)) {
      return element.getAttribute(attr);
    }
  }

  return null;
}

/**
 * Check if button text is unique enough to use as a selector
 * Also filters out overly generic words that shouldn't be used alone
 */
function isUniqueButtonText(text: string): boolean {
  if (!text || text.length < 2) {
    return false;
  }

  // Too short or too generic - always need more context
  const genericWords = [
    'new',
    'add',
    'save',
    'cancel',
    'close',
    'ok',
    'yes',
    'no',
    'edit',
    'delete',
    'remove',
    'update',
    'submit',
    'back',
    'next',
    'confirm',
    'apply',
    'reset',
    'clear',
    'search',
    'filter',
  ];

  if (text.length < 4 || genericWords.includes(text.toLowerCase())) {
    return false; // Always need parent context for these
  }

  // Use findButtonByText to check uniqueness
  const buttons = findButtonByText(text);
  return buttons.length === 1;
}

// Note: buildCompoundSelector was replaced by buildCompoundSelectorWithContext
// which provides better specificity by including parent context

/**
 * Find the best element in the hierarchy - SIMPLIFIED
 *
 * Core principle: Find the actual interactive element (input, button, link)
 * with the best testid or id, not wrapper divs.
 */
function findBestElementInHierarchy(
  element: HTMLElement,
  maxDepth = 5,
  options?: { clickX?: number; clickY?: number }
): HTMLElement {
  // STEP 1: Search siblings and nearby elements for form controls
  // When user clicks SVG/icon near an input, find that input!
  const nearbyInput = findNearbyFormControl(element, 3);
  if (nearbyInput) {
    return nearbyInput;
  }

  // STEP 2: If element itself is interactive with testid/id, use it
  const tag = element.tagName.toLowerCase();
  const hasGoodAttribute =
    getAnyTestId(element) || (element.id && !isAutoGeneratedId(element.id)) || element.hasAttribute('aria-label');

  if (hasGoodAttribute && ['input', 'select', 'textarea', 'button', 'a'].includes(tag)) {
    return element;
  }

  // STEP 3: Walk up to find element with testid/id (max 5 levels)
  let current: HTMLElement | null = element;
  let depth = 0;

  while (current && depth < maxDepth) {
    const currentTag = current.tagName.toLowerCase();
    const currentTestId = getAnyTestId(current);
    const currentId = current.id && !isAutoGeneratedId(current.id);

    // Prefer actual interactive elements with good attributes
    if ((currentTestId || currentId) && ['input', 'select', 'textarea', 'button', 'a', 'label'].includes(currentTag)) {
      return current;
    }

    // For buttons/links without testid, still prefer them over divs
    if (['button', 'a'].includes(currentTag)) {
      return current;
    }

    // Take first element with testid (even if it's a div)
    if (currentTestId) {
      return current;
    }

    current = current.parentElement;
    depth++;
  }

  // STEP 4: Fall back to original element
  return element;
}

/**
 * Find nearby form control (input, select, textarea) when user clicks icon/wrapper
 * This handles cases like clicking SVG dropdown arrow next to an input
 * For radio/checkbox, prefers the label over the input
 */
function findNearbyFormControl(element: HTMLElement, maxDepth: number): HTMLElement | null {
  let current: HTMLElement | null = element;
  let depth = 0;

  while (current && depth < maxDepth) {
    // For radio/checkbox, look for labels first (better selectors with text)
    const label = current.querySelector('label[for]');
    if (label instanceof HTMLElement) {
      const forAttr = label.getAttribute('for');
      if (forAttr) {
        const associatedInput = document.getElementById(forAttr);
        if (associatedInput instanceof HTMLInputElement && ['radio', 'checkbox'].includes(associatedInput.type)) {
          return label; // Return the label for radio/checkbox
        }
      }
    }

    // Look for form controls with testid or id (but not radio/checkbox inputs)
    const formControl = current.querySelector(
      'input[data-testid], select[data-testid], textarea[data-testid], input[id], select[id], textarea[id]'
    );
    if (formControl instanceof HTMLElement) {
      // Skip radio/checkbox inputs - we want their labels instead
      if (formControl.tagName === 'INPUT') {
        const inputType = (formControl as HTMLInputElement).type;
        if (inputType === 'radio' || inputType === 'checkbox') {
          // Look for its label
          const inputId = formControl.id;
          if (inputId) {
            const associatedLabel = document.querySelector(`label[for="${inputId}"]`);
            if (associatedLabel instanceof HTMLElement) {
              return associatedLabel;
            }
          }
          // No label found, continue searching
        } else {
          return formControl; // Other input types are fine
        }
      } else {
        return formControl; // Select/textarea are fine
      }
    }

    current = current.parentElement;
    depth++;
  }

  return null;
}

/**
 * List of dynamic/unstable attribute patterns to remove from selectors
 */
const DYNAMIC_ATTRIBUTE_PATTERNS = [
  /\[data-new-gr-c-s-check-loaded="[^"]*"\]/, // Grammarly extension
  /\[data-gr-ext-installed="[^"]*"\]/, // Grammarly extension
  /\[data-gr-ext-disabled="[^"]*"\]/, // Grammarly extension
  /\[data-testid="data-testid [^"]*"\]\[data-testid="data-testid [^"]*"\]/, // Duplicate testids
];

/**
 * Clean selector by removing dynamic/unstable attributes
 */
function cleanDynamicAttributes(selector: string): string {
  let cleaned = selector;

  // Remove dynamic attribute patterns
  for (const pattern of DYNAMIC_ATTRIBUTE_PATTERNS) {
    cleaned = cleaned.replace(pattern, '');
  }

  // Remove theme classes (theme-dark, theme-light)
  cleaned = cleaned.replace(/\.theme-(?:dark|light)/g, '');

  // Remove body tag with only dynamic attributes
  if (cleaned.match(/^body[^:>\s]*:nth-of-type\(1\)$/)) {
    // Body with only nth-of-type is useless - this shouldn't happen
    return 'body';
  }

  // Clean up multiple spaces and trailing combinators
  cleaned = cleaned.replace(/\s+/g, ' ').trim();
  cleaned = cleaned.replace(/\s+>/g, '>').replace(/>\s+/g, '>');

  return cleaned;
}

/**
 * Generate the best CSS selector for a given DOM element
 *
 * This is the main entry point for selector generation. It automatically:
 * - Walks up the DOM tree to find the most semantically meaningful parent
 * - Prioritizes stable attributes over fragile ones
 * - Handles edge cases like clicking icons inside buttons/links
 * - Returns production-ready selectors suitable for test automation
 *
 * Priority order:
 * 1. data-testid attribute (most stable for testing)
 * 2. Non-auto-generated ID
 * 3. aria-label (semantic and accessible)
 * 4. name attribute (for form inputs)
 * 5. href attribute (for links)
 * 6. Unique button text (using findButtonByText)
 * 7. Compound selector with parent context
 * 8. Fallback to :nth-of-type
 *
 * @param element - Any HTMLElement from the DOM
 * @param options - Optional click coordinates for coordinate-aware selection
 * @returns A CSS selector string that can be used with querySelector/querySelectorAll
 *
 * @example
 * ```typescript
 * // Clicking a span inside a navigation link
 * const span = document.querySelector('a[href="/dashboards"] > span');
 * const selector = generateBestSelector(span);
 * // Returns: "a[data-testid='Nav menu item'][href='/dashboards']"
 *
 * // Clicking a button with unique text
 * const button = document.querySelector('button');
 * const selector = generateBestSelector(button);
 * // Returns: "Save Dashboard" (uses button text matching)
 *
 * // With click coordinates to find button inside card
 * const selector = generateBestSelector(cardElement, { clickX: 100, clickY: 200 });
 * // Returns selector for the button at those coordinates
 * ```
 */
export function generateBestSelector(element: HTMLElement, options?: { clickX?: number; clickY?: number }): string {
  // First, walk up to find the best element in the hierarchy
  const bestElement = findBestElementInHierarchy(element, 5, options);

  // 1. Check any test ID attribute (most stable)
  const testId = getAnyTestId(bestElement);
  if (testId) {
    const tag = bestElement.tagName.toLowerCase();
    // Determine which attribute was used
    const testIdAttr =
      ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'].find((attr) =>
        bestElement.hasAttribute(attr)
      ) || 'data-testid';

    // For links, include normalized href for specificity
    if (tag === 'a' && bestElement.hasAttribute('href')) {
      const href = normalizeHref(bestElement.getAttribute('href')!);
      const baseSelector = `${tag}[${testIdAttr}="${testId}"][href="${href}"]`;

      // Test IDs are usually unique - only add context if truly needed
      const matches = querySelectorAllEnhanced(baseSelector);
      if (matches.elements.length === 1) {
        return cleanDynamicAttributes(baseSelector); // Simple and unique!
      }

      const contextualSelector = buildContextualSelector(bestElement, baseSelector);
      return cleanDynamicAttributes(contextualSelector);
    }

    // Simple test ID selector - check if it's unique first
    const baseSelector = `${tag}[${testIdAttr}="${testId}"]`;
    const matches = querySelectorAllEnhanced(baseSelector);

    if (matches.elements.length === 1) {
      // Test ID is unique - return simple selector!
      return cleanDynamicAttributes(baseSelector);
    }

    // Not unique - add context
    const contextualSelector = buildContextualSelector(bestElement, baseSelector);
    return cleanDynamicAttributes(contextualSelector);
  }

  // 2. Check ID (if not auto-generated)
  if (bestElement.id && !isAutoGeneratedId(bestElement.id)) {
    const baseSelector = `#${bestElement.id}`;

    // IDs should be unique - check first
    const matches = querySelectorAllEnhanced(baseSelector);
    if (matches.elements.length === 1) {
      return cleanDynamicAttributes(baseSelector); // Simple and unique!
    }

    // Not unique (rare for IDs) - add context
    const contextualSelector = buildContextualSelector(bestElement, baseSelector);
    return cleanDynamicAttributes(contextualSelector);
  }

  // 3. For buttons, prioritize visible text over aria-label (users interact with what they see)
  if (bestElement.tagName === 'BUTTON') {
    const text = bestElement.textContent;
    if (text && text.length > 0) {
      const cleanText = normalizeText(text);

      if (cleanText.length > 0 && cleanText.length < 50) {
        // Strategy A: Parent context + :contains (preferred for most buttons)
        const parent = bestElement.parentElement;
        if (parent && (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label'))) {
          // Don't pass click coordinates to parent - they only apply to the clicked element
          const parentSelector = generateBestSelector(parent);
          const fullSelector = `${parentSelector} button:contains("${cleanText}")`;
          return cleanDynamicAttributes(fullSelector);
        }

        // Strategy B: Standalone text ONLY if unique AND not generic
        if (isUniqueButtonText(cleanText)) {
          return cleanText; // Will use findButtonByText
        }

        // Strategy C: Standalone :contains as fallback (with validation)
        const baseSelector = `button:contains("${cleanText}")`;
        const contextualSelector = buildContextualSelector(bestElement, baseSelector);
        return cleanDynamicAttributes(contextualSelector);
      }
    }
  }

  // 4. Check aria-label (semantic and stable) - but after button text
  if (bestElement.hasAttribute('aria-label')) {
    const ariaLabel = bestElement.getAttribute('aria-label');
    const tag = bestElement.tagName.toLowerCase();
    const baseSelector = `${tag}[aria-label="${ariaLabel}"]`;
    const contextualSelector = buildContextualSelector(bestElement, baseSelector);
    return cleanDynamicAttributes(contextualSelector);
  }

  // 5. For labels, use text content (best for radio/checkbox) or 'for' attribute prefix
  if (bestElement.tagName === 'LABEL') {
    const text = normalizeText(bestElement.textContent || '');
    const forAttr = bestElement.getAttribute('for');

    // Strategy A: For radio buttons, use text content with :contains() - most stable!
    if (text.length > 0 && text.length < 50) {
      // Check if this is a radio/checkbox label by looking at associated input
      const associatedInput = forAttr ? document.getElementById(forAttr) : null;
      const isRadioOrCheckbox =
        associatedInput &&
        (associatedInput as HTMLInputElement).type &&
        ['radio', 'checkbox'].includes((associatedInput as HTMLInputElement).type);

      if (isRadioOrCheckbox) {
        // For radio/checkbox, prefer text-based selection
        const textSelector = `label:contains("${text}")`;
        const matches = querySelectorAllEnhanced(textSelector);
        if (matches.elements.length === 1) {
          return cleanDynamicAttributes(textSelector);
        }

        // If not unique by text alone, add parent context
        const contextualSelector = buildContextualSelector(bestElement, textSelector);
        return cleanDynamicAttributes(contextualSelector);
      }
    }

    // Strategy B: Use 'for' attribute with prefix match (handles auto-generated IDs)
    if (forAttr) {
      // Try to find a stable prefix (e.g., "option-lines-radiogroup-34" -> "option-lines-")
      const prefixMatch = forAttr.match(/^([a-z-]+(?:-[a-z]+)?)-/);
      if (prefixMatch) {
        const prefix = prefixMatch[1];
        const prefixSelector = `label[for^="${prefix}-"]`;

        // If text content exists, combine prefix with text for best specificity
        if (text.length > 0 && text.length < 50) {
          const combinedSelector = `${prefixSelector}:contains("${text}")`;
          const matches = querySelectorAllEnhanced(combinedSelector);
          if (matches.elements.length === 1) {
            return cleanDynamicAttributes(combinedSelector);
          }
        }
      }

      // Strategy C: Full 'for' attribute as fallback
      const baseSelector = `label[for="${forAttr}"]`;
      const matches = querySelectorAllEnhanced(baseSelector);
      if (matches.elements.length === 1) {
        return cleanDynamicAttributes(baseSelector);
      }

      const contextualSelector = buildContextualSelector(bestElement, baseSelector);
      return cleanDynamicAttributes(contextualSelector);
    }

    // Strategy D: Text-only label (no 'for' attribute)
    if (text.length > 0 && text.length < 50) {
      const textSelector = `label:contains("${text}")`;
      const contextualSelector = buildContextualSelector(bestElement, textSelector);
      return cleanDynamicAttributes(contextualSelector);
    }
  }

  // 6. For inputs, check id first (better than name for radio/checkbox)
  if (
    (bestElement.tagName === 'INPUT' || bestElement.tagName === 'TEXTAREA' || bestElement.tagName === 'SELECT') &&
    bestElement.hasAttribute('id') &&
    !isAutoGeneratedId(bestElement.id)
  ) {
    const id = bestElement.id;
    const tag = bestElement.tagName.toLowerCase();
    const baseSelector = `${tag}[id="${id}"]`;

    // IDs should be unique
    const matches = querySelectorAllEnhanced(baseSelector);
    if (matches.elements.length === 1) {
      return cleanDynamicAttributes(baseSelector); // Simple and unique!
    }

    const contextualSelector = buildContextualSelector(bestElement, baseSelector);
    return cleanDynamicAttributes(contextualSelector);
  }

  // 7. For inputs, check name attribute (but NOT for radio/checkbox - they share names!)
  if (
    (bestElement.tagName === 'INPUT' || bestElement.tagName === 'TEXTAREA' || bestElement.tagName === 'SELECT') &&
    bestElement.hasAttribute('name')
  ) {
    const tag = bestElement.tagName.toLowerCase();

    // Skip name attribute for radio/checkbox - all options share the same name!
    // Better to use their associated label with text
    if (tag === 'input') {
      const inputType = (bestElement as HTMLInputElement).type?.toLowerCase();
      if (inputType === 'radio' || inputType === 'checkbox') {
        // Try to find associated label instead
        const inputId = bestElement.id;
        if (inputId) {
          const label = document.querySelector(`label[for="${inputId}"]`);
          if (label instanceof HTMLElement) {
            // Recursively generate selector for the label (which has better text-based selection)
            return generateBestSelector(label);
          }
        }
        // If no label found, skip to compound selector (don't use name attribute)
      } else {
        // For other input types (text, email, etc.), name is fine
        const name = bestElement.getAttribute('name');
        const baseSelector = `${tag}[name="${name}"]`;
        const contextualSelector = buildContextualSelector(bestElement, baseSelector);
        return cleanDynamicAttributes(contextualSelector);
      }
    } else {
      // For textarea/select, name is fine
      const name = bestElement.getAttribute('name');
      const baseSelector = `${tag}[name="${name}"]`;
      const contextualSelector = buildContextualSelector(bestElement, baseSelector);
      return cleanDynamicAttributes(contextualSelector);
    }
  }

  // 8. For links with href, use normalized pathname
  if (bestElement.tagName === 'A' && bestElement.hasAttribute('href')) {
    const href = normalizeHref(bestElement.getAttribute('href')!);
    const baseSelector = `a[href="${href}"]`;
    const contextualSelector = buildContextualSelector(bestElement, baseSelector);
    return cleanDynamicAttributes(contextualSelector);
  }

  // 9. Build compound selector with tag + attributes + parent context
  const compoundSelector = buildCompoundSelectorWithContext(bestElement);
  const contextualSelector = buildContextualSelector(bestElement, compoundSelector);

  // 10. Post-process: Clean dynamic attributes
  const cleanedSelector = cleanDynamicAttributes(contextualSelector);

  // 11. FINAL VALIDATION: Check if selector matches anything
  try {
    const matches = querySelectorAllEnhanced(cleanedSelector);
    if (matches.elements.length === 0) {
      console.warn(`Generated selector has 0 matches: "${cleanedSelector}"`);
    }
  } catch (error) {
    console.warn('Selector validation error:', error);
  }

  return cleanedSelector;
}

/**
 * Build contextual selector - SIMPLIFIED
 * Only add context if base selector is ambiguous
 * Priority: parent context > text content > nth-match
 */
function buildContextualSelector(element: HTMLElement, baseSelector: string): string {
  try {
    const matches = querySelectorAllEnhanced(baseSelector);

    // Already unique or no matches - return as-is
    if (matches.elements.length <= 1) {
      return baseSelector;
    }

    // Strategy 1: Try simple parent context
    const parentContext = findSimpleParentContext(element, baseSelector);
    if (parentContext) {
      return parentContext;
    }

    // Strategy 2: Try text content with :contains() - much more stable than position!
    const text = normalizeText(element.textContent || '');
    if (text.length > 0 && text.length < 100) {
      const textSelector = `${baseSelector}:contains("${text}")`;
      try {
        const textMatches = querySelectorAllEnhanced(textSelector);
        if (textMatches.elements.length === 1 && textMatches.elements[0] === element) {
          return textSelector;
        }
      } catch (e) {
        // :contains() failed, try next strategy
      }
    }

    // Strategy 3: Last resort - Use :nth-match() (fragile, but better than nothing)
    const index = matches.elements.indexOf(element);
    if (index >= 0) {
      return `${baseSelector}:nth-match(${index + 1})`;
    }

    return baseSelector;
  } catch (error) {
    console.warn(`Context validation failed for "${baseSelector}":`, error);
    return baseSelector;
  }
}

/**
 * Try to add simple parent context (no complex :has() selectors)
 */
function findSimpleParentContext(element: HTMLElement, baseSelector: string): string | null {
  let current = element.parentElement;
  let depth = 0;

  while (current && depth < 2) {
    const testId = getAnyTestId(current);
    const id = current.id && !isAutoGeneratedId(current.id);

    if (testId) {
      const tag = current.tagName.toLowerCase();
      const testIdAttr =
        ['data-testid', 'data-cy', 'data-test-id', 'data-qa', 'data-test-subj'].find((attr) =>
          current!.hasAttribute(attr)
        ) || 'data-testid';
      const parentSelector = `${tag}[${testIdAttr}="${testId}"]`;
      const candidateSelector = `${parentSelector} ${baseSelector}`;

      try {
        const result = querySelectorAllEnhanced(candidateSelector);
        if (result.elements.length === 1 && result.elements[0] === element) {
          return candidateSelector;
        }
      } catch (e) {
        // Try next parent
      }
    }

    if (id) {
      const candidateSelector = `#${id} ${baseSelector}`;
      try {
        const result = querySelectorAllEnhanced(candidateSelector);
        if (result.elements.length === 1 && result.elements[0] === element) {
          return candidateSelector;
        }
      } catch (e) {
        // Try next parent
      }
    }

    current = current.parentElement;
    depth++;
  }

  return null;
}

/**
 * Build compound selector with parent context for better specificity
 * Uses parent selectors and :contains() when appropriate
 */
function buildCompoundSelectorWithContext(element: HTMLElement): string {
  const tag = element.tagName.toLowerCase();
  const parts: string[] = [tag];

  // Add meaningful classes
  const meaningfulClasses = getMeaningfulClasses(element);
  if (meaningfulClasses.length > 0) {
    parts.push(`.${meaningfulClasses[0]}`);
  }

  // Add data attributes (except auto-generated ones)
  Array.from(element.attributes).forEach((attr) => {
    if (
      attr.name.startsWith('data-') &&
      !attr.name.includes('emotion') &&
      !attr.name.includes('react') &&
      attr.value.length < 50
    ) {
      parts.push(`[${attr.name}="${attr.value}"]`);
    }
  });

  // Add normalized href for links
  if (tag === 'a' && element.hasAttribute('href')) {
    const href = normalizeHref(element.getAttribute('href')!);
    parts.push(`[href="${href}"]`);
  }

  // If we still don't have enough specificity, try these strategies:

  // Strategy 1: Use parent context if parent has good identifiers
  if (parts.length <= 2 && element.parentElement) {
    const parent = element.parentElement;

    // Check if parent has good identifying attributes
    if (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label')) {
      const parentSelector = generateBestSelector(parent);

      // For buttons with text, use :contains for better readability
      if (tag === 'button' && element.textContent) {
        const text = normalizeText(element.textContent);
        if (text.length > 0 && text.length < 50) {
          return `${parentSelector} button:contains("${text}")`;
        }
      }

      return `${parentSelector} ${parts.join('')}`;
    }
  }

  // Strategy 2: Use :contains as fallback for LEAF elements only (buttons/links with short text)
  if ((tag === 'button' || tag === 'a') && element.textContent) {
    const text = normalizeText(element.textContent);
    if (text.length > 0 && text.length < 50) {
      return `${tag}:contains("${text}")`;
    }
  }

  // Strategy 3 removed - let buildContextualSelector handle text-based context via :has()
  // This prevents container divs from using their full nested text content

  // Strategy 4: Add :nth-of-type with parent context as last resort
  if (element.parentElement) {
    const siblings = Array.from(element.parentElement.children).filter((el) => el.tagName === element.tagName);
    const index = siblings.indexOf(element) + 1;
    if (index > 0) {
      parts.push(`:nth-of-type(${index})`);

      // Try to add parent context for better specificity
      const parent = element.parentElement;
      if (getAnyTestId(parent) || parent.id || parent.hasAttribute('aria-label')) {
        const parentSelector = generateBestSelector(parent);
        return `${parentSelector} > ${parts.join('')}`;
      }
    }
  }

  // Absolute last resort: just return what we have
  return parts.length > 0 ? parts.join('') : `${tag}`;
}

/**
 * Get information about the generated selector for debugging
 * Returns the selector along with metadata about how it was generated
 *
 * @param element - The DOM element to analyze
 * @returns Object containing selector, generation method, uniqueness, match count, and context strategy
 *
 * @example
 * ```typescript
 * const info = getSelectorInfo(myElement);
 * console.log(info.selector); // "button[data-testid='save']"
 * console.log(info.method);   // "data-testid"
 * console.log(info.isUnique); // true
 * console.log(info.contextStrategy); // "child-has"
 * ```
 */
export function getSelectorInfo(element: HTMLElement): {
  selector: string;
  method: string;
  isUnique: boolean;
  matchCount: number;
  contextStrategy?: string;
} {
  const selector = generateBestSelector(element);

  // Determine which method was used
  let method = 'compound';
  if (selector.includes('data-testid') || selector.includes('data-cy') || selector.includes('data-test-id')) {
    method = 'data-testid';
  } else if (selector.startsWith('#')) {
    method = 'id';
  } else if (selector.includes('aria-label')) {
    method = 'aria-label';
  } else if (selector.includes('[name=')) {
    method = 'name';
  } else if (selector.includes('[href=')) {
    method = 'href';
  } else if (!selector.includes('[') && !selector.includes('.') && !selector.includes('#') && !selector.includes(':')) {
    method = 'button-text';
  } else if (selector.includes(':nth-of-type')) {
    method = 'nth-of-type';
  } else if (selector.includes(':contains(')) {
    method = 'contains';
  }

  // Determine context strategy used
  let contextStrategy: string | undefined;
  if (selector.includes(':has(')) {
    contextStrategy = 'child-has';
  } else if (selector.includes(':nth-match(')) {
    contextStrategy = 'nth-match';
  } else if (selector.includes(' ') && !selector.includes(':contains(')) {
    // Has descendant combinator (space) but not just :contains
    contextStrategy = 'parent-context';
  }

  // Check uniqueness using enhanced selector for :contains() and :has() support
  let matchCount = 0;
  try {
    if (method === 'button-text') {
      matchCount = findButtonByText(selector).length;
    } else if (method === 'contains' || selector.includes(':has(') || selector.includes(':nth-match(')) {
      // Use enhanced selector for complex pseudo-selectors
      const result = querySelectorAllEnhanced(selector);
      matchCount = result.elements.length;
    } else {
      matchCount = document.querySelectorAll(selector).length;
    }
  } catch (error) {
    matchCount = 0;
  }

  return {
    selector,
    method,
    isUnique: matchCount === 1,
    matchCount,
    contextStrategy,
  };
}
