/**
 * Package Type Definitions
 *
 * Types for the two-file package model: content.json + manifest.json.
 * Packages are directories containing at minimum content.json, with
 * optional manifest.json for metadata, dependencies, and targeting.
 *
 * @coupling Zod schemas: package.schema.ts - schemas must stay in sync
 */

import type { JsonBlock } from './json-guide.types';

// ============ CONTENT (content.json) ============

/**
 * Content file schema — what the block editor produces.
 * Contains only the fields needed to render the guide.
 * @coupling Zod schema: ContentJsonSchema in package.schema.ts
 */
export interface ContentJson {
  schemaVersion?: string;
  id: string;
  title: string;
  blocks: JsonBlock[];
}

// ============ DEPENDENCY TYPES ============

/**
 * A dependency clause: either a single bare package ID (string)
 * or an OR-group of alternative package IDs (string[]).
 * Follows Debian's dependency syntax in JSON form.
 */
export type DependencyClause = string | string[];

/**
 * A list of dependency clauses combined with AND (CNF).
 * Each clause is a bare string (single reference) or an
 * array of strings (OR-group of alternatives).
 *
 * Debian mapping: comma = AND, pipe = OR.
 * - `["A", "B"]`             → A AND B
 * - `[["A", "B"]]`           → A OR B
 * - `[["A", "B"], "C"]`      → (A OR B) AND C
 */
export type DependencyList = DependencyClause[];

// ============ AUTHOR ============

/**
 * Content author or owning team.
 */
export interface Author {
  name?: string;
  team?: string;
}

// ============ TARGETING ============

/**
 * Advisory recommendation targeting.
 * The `match` field follows the recommender's MatchExpr grammar.
 * We define this loosely — the recommender owns the match semantics.
 */
export interface GuideTargeting {
  match?: Record<string, unknown>;
}

// ============ TEST ENVIRONMENT ============

/**
 * Test environment metadata for Layer 4 E2E routing.
 * Declares what infrastructure a guide needs for testing.
 */
export interface TestEnvironment {
  tier?: string;
  minVersion?: string;
  datasets?: string[];
  datasources?: string[];
  plugins?: string[];
  /**
   * Host-only name of a specific Grafana instance where this guide should be
   * tested (e.g. `play.grafana.org` or `myslug.grafana.net`).
   * Must not include a protocol or path — just the hostname.
   * When omitted, any instance that conforms to the declared tier may be used.
   */
  instance?: string;
}

// ============ PACKAGE TYPE ============

/** Valid package type values */
export type PackageType = 'guide' | 'path' | 'journey';

// ============ SHARED METADATA ============

/**
 * Shared package metadata fields present in RepositoryEntry, GraphNode,
 * and (partially) ManifestJson. Extracted to keep these in sync.
 * @coupling Zod schema: packageMetadataSchemaFields in package.schema.ts
 */
export interface PackageMetadataFields {
  type: PackageType;
  title?: string;
  description?: string;
  category?: string;
  author?: Author;
  startingLocation?: string;
  steps?: string[];
  depends?: DependencyList;
  recommends?: DependencyList;
  suggests?: DependencyList;
  provides?: string[];
  conflicts?: string[];
  replaces?: string[];
}

// ============ MANIFEST (manifest.json) ============

/**
 * Manifest file schema — metadata, dependencies, and targeting.
 * Authored by product, enablement, or recommender teams.
 * @coupling Zod schema: ManifestJsonSchema in package.schema.ts
 */
export interface ManifestJson {
  schemaVersion?: string;
  id: string;
  type: PackageType;
  repository?: string;

  steps?: string[];

  description?: string;
  language?: string;
  category?: string;
  author?: Author;
  startingLocation?: string;

  depends?: DependencyList;
  recommends?: DependencyList;
  suggests?: DependencyList;
  provides?: string[];
  conflicts?: string[];
  replaces?: string[];

  targeting?: GuideTargeting;
  testEnvironment?: TestEnvironment;
}

// ============ REPOSITORY INDEX ============

/**
 * A single entry in repository.json.
 * Denormalized manifest metadata for dependency graph building
 * without re-reading every manifest.json.
 */
export interface RepositoryEntry extends PackageMetadataFields {
  path: string;
  targeting?: GuideTargeting;
  testEnvironment?: TestEnvironment;
}

/**
 * Repository index mapping bare package IDs to entry metadata.
 * Generated by `pathfinder-cli build-repository`.
 * @coupling Zod schema: RepositoryJsonSchema in package.schema.ts
 */
export interface RepositoryJson {
  [packageId: string]: RepositoryEntry;
}

// ============ RESOLUTION TYPES ============

/**
 * Successful package resolution — the resolver found the package and
 * built URLs for its content and manifest.
 * @coupling PackageResolver in package-engine/
 */
export interface PackageResolutionSuccess {
  ok: true;
  id: string;
  /**
   * Opaque locator for the package's content.json, consumed by the
   * package-engine loader — NOT compatible with the docs-retrieval
   * fetchContent() pipeline which uses a different `bundled:<id>` scheme.
   */
  contentUrl: string;
  /**
   * Opaque locator for the package's manifest.json, consumed by the
   * package-engine loader.
   */
  manifestUrl: string;
  repository: string;
  /** Populated when resolve options request content loading */
  manifest?: ManifestJson;
  /** Populated when resolve options request content loading */
  content?: ContentJson;
}

/**
 * Structured error from a failed resolution attempt.
 */
export interface ResolutionError {
  code: 'not-found' | 'network-error' | 'parse-error' | 'validation-error';
  message: string;
}

/**
 * Failed package resolution — the resolver could not produce a result.
 */
export interface PackageResolutionFailure {
  ok: false;
  id: string;
  error: ResolutionError;
}

/** Discriminated union: callers must check `.ok` before accessing data. */
export type PackageResolution = PackageResolutionSuccess | PackageResolutionFailure;

/**
 * Options for {@link PackageResolver.resolve}.
 */
export interface ResolveOptions {
  /** When true, fetch and populate manifest and content on the resolution result */
  loadContent?: boolean;
}

/**
 * Resolves bare package IDs to content/manifest locations.
 * Implementations may back onto bundled content, a static catalog, or a registry service.
 */
export interface PackageResolver {
  resolve(packageId: string, options?: ResolveOptions): Promise<PackageResolution>;
}

// ============ GRAPH TYPES ============

/**
 * A node in the dependency graph.
 * Contains full manifest metadata from the denormalized repository.json.
 */
export interface GraphNode extends PackageMetadataFields {
  id: string;
  repository: string;
  /** True for virtual capability nodes (not real packages) */
  virtual?: boolean;
}

/** Edge types in the dependency graph */
export type GraphEdgeType = 'depends' | 'recommends' | 'suggests' | 'provides' | 'conflicts' | 'replaces' | 'steps';

/**
 * An edge in the dependency graph.
 * Source and target are bare package IDs.
 */
export interface GraphEdge {
  source: string;
  target: string;
  type: GraphEdgeType;
}

/**
 * D3-compatible graph output format.
 */
export interface DependencyGraph {
  nodes: GraphNode[];
  edges: GraphEdge[];
  metadata: {
    generatedAt: string;
    repositories: string[];
    nodeCount: number;
    edgeCount: number;
  };
}
